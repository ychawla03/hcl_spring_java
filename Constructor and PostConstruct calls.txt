Fantastic — you’ve built a really clean and realistic Spring Core example

Let’s understand step by step, with reasoning behind constructor calls, @Primary, 
@Qualifier, @PostConstruct, and @PreDestroy

We have:

| Component         | Type                                                     | Scope               | Special                                            |
| ----------------- | -------------------------------------------------------- | ------------------- | -------------------------------------------------- |
| `CricketCoach`    | `@Component`                                             | Singleton (default) | Has commented-out `@PostConstruct` / `@PreDestroy` |
| `FootballCoach`   | `@Component`                                             | Prototype           | Marked `@Primary`                                  |
| `ScoreRepository` | `@Repository`                                            | Singleton           | Used by `TrainingService`                          |
| `TrainingService` | `@Service`                                               | Singleton           | Injects `Coach` + `ScoreRepository`                |
| `MainApp`         | Manually bootstraps `AnnotationConfigApplicationContext` | —                   | Calls `ctx.close()`                                |


So:
We have 2 Coach beans: cricketCoach(singleton) and footballCoach(prototype).
We inject @Qualifier("cricketCoach") inside TrainingService.

What happens when the app starts

Step 1: Context Creation
AnnotationConfigApplicationContext ctx = new 
AnnotationConfigApplicationContext(AppConfig.class);

Spring:Loads AppConfig
Runs component scanning on com.example.springcore.annotations
Finds all @Component, @Service, @Repository beans.

Beans discovered:
cricketCoach, footballCoach, scoreRepository, trainingService

Step 2: Bean Instantiation Sequence
Spring needs to create trainingService, but before that it must resolve its dependencies.


public TrainingService(@Qualifier("cricketCoach") Coach coach, ScoreRepository repo) {
Spring must provide:
a Coach bean named "cricketCoach"
a ScoreRepository bean
So internally:
It sees @Qualifier("cricketCoach"), so it specifically chooses the CricketCoach 
bean (even though FootballCoach is @Primary — Qualifier always wins).

Creates CricketCoach first.
Creates ScoreRepository.
Injects both into TrainingService.
Creates the TrainingService bean itself.

Step 3: Constructor invocation order
So you’ll see (assuming you uncomment the PostConstruct later):

[FootballCoach] constructor: instance id#1 - not yet
[CricketCoach] constructor called
[TrainingService] constructor called

Wait — FootballCoach constructor won’t appear unless it’s actually requested.
Because:
It’s a prototype bean, and
It’s not injected anywhere,
so Spring knows about it but doesn’t instantiate it until someone explicitly calls 
ctx.getBean(FootballCoach.class).

IMPORTANT POINT: Singleton beans are created eagerly during context startup.
IMPORTANT POINT: Prototype beans are created lazily (only when requested).


Step 4: @PostConstruct invocation
Now Spring calls any methods annotated with @PostConstruct.
But your CricketCoach has:

//@PostConstruct
public void init() { ... }
Because @PostConstruct is commented out, it will never run.
That’s why you didn’t see it in your logs.

If you uncomment @PostConstruct:

@PostConstruct
public void init() {
    System.out.println("[CricketCoach] @PostConstruct: Ready for training, Team:" + teamName);
}

then after the constructor and dependency injection, Spring will call it automatically.

Step 5: @PreDestroy invocation
Now, when you call:

ctx.close();

Spring gracefully shuts down the context.
It will invoke all @PreDestroy methods for singleton beans only.
Prototype beans do not receive destroy callbacks automatically (you’d have to destroy 
them manually).

So if you uncomment this:

@PreDestroy
public void destroy() {
    System.out.println("[CricketCoach] @PreDestroy: Wrapping up resource");
}

You’ll see this message when you close the context.


| Bean            | Scope     | When Constructor Runs      | @PostConstruct              | @PreDestroy        | Injected?            |
| --------------- | --------- | -------------------------- | --------------------------- | ------------------ | -------------------- |
| CricketCoach    | Singleton | At startup                 | Yes (if annotation present) | Yes (on ctx.close) | Yes (via @Qualifier) |
| FootballCoach   | Prototype | Only if `getBean()` called | Yes (if annotation present) | ❌ Not automatic    | Not injected         |
| ScoreRepository | Singleton | At startup                 | (no method)                 | (no method)        | Yes                  |
| TrainingService | Singleton | After dependencies created | (no method)                 | (no method)        | n/a                  |


Why you saw only one constructor called
Because:
You never requested FootballCoach from context,
And it’s prototype scoped (so it’s lazy).
Hence, Spring never instantiated it.

If you do this in your MainApp:

ctx.getBean(FootballCoach.class);
you’ll suddenly see:

[FootballCoach] constructor: instance id#1
And if you call it twice:

ctx.getBean(FootballCoach.class);
ctx.getBean(FootballCoach.class);
you’ll see:

[FootballCoach] constructor: instance id#1
[FootballCoach] constructor: instance id#2

because prototype beans always create a new instance.

@Primary vs @Qualifier clarity


| Situation                                  | Which Bean Injected                                 |
| ------------------------------------------ | --------------------------------------------------- |
| `@Primary` on FootballCoach, no @Qualifier | FootballCoach injected                              |
| `@Qualifier("cricketCoach")` used          | CricketCoach injected (Qualifier overrides Primary) |
| No @Primary and no @Qualifier              | ❌ Ambiguity error                                   |
| Only one Coach bean present                | That one injected automatically                     |


So, your case:

public TrainingService(@Qualifier("cricketCoach") Coach coach, ...)
explicitly chooses CricketCoach, ignoring the @Primary on FootballCoach.

Visual timeline for your current setup

Spring Context Bootstraps →
  ↓
Finds beans: CricketCoach, FootballCoach, ScoreRepository, TrainingService
  ↓
CricketCoach constructor runs
  ↓
CricketCoach @PostConstruct (if present)
  ↓
ScoreRepository created
  ↓
TrainingService constructor runs (gets injected CricketCoach + ScoreRepository)
  ↓
TrainingService ready
  ↓
App logic runs (service.trainingPlan(...))
  ↓
ctx.close()
  ↓
CricketCoach @PreDestroy called

Small Experiment You Can Try
Try these quick toggles and watch logs change:

| Change                                                            | What Happens                                  |
| ----------------------------------------------------------------- | --------------------------------------------- |
| Uncomment `@PostConstruct` & `@PreDestroy` in CricketCoach        | See lifecycle messages                        |
| Remove `@Qualifier` from TrainingService                          | App fails (ambiguous Coach)                   |
| Add `@Primary` on CricketCoach instead                            | App works without @Qualifier                  |
| Keep `@Qualifier("cricketCoach")` but mark FootballCoach @Primary | Works fine, because Qualifier wins            |
| Call `ctx.getBean(FootballCoach.class)` twice                     | See new instance created twice                |
| Add `@Scope("prototype")` to CricketCoach                         | Now its `@PreDestroy` won’t run automatically |



The key principle to remember

Spring creates all singleton beans at startup.
Prototype beans are created only when requested.
@PostConstruct runs after dependency injection.
@PreDestroy runs only for singletons on context close.
@Qualifier always overrides @Primary.




what if one bean has no @PostContruct, it has simple constructor in a class, 
will it work and how that falls in above understanding?


Every Spring bean must have a constructor

When you mark a class as a Spring-managed bean (@Component, @Service, etc.), Spring must 
create an instance of that class.

So, even if you don’t write @PostConstruct, the bean’s constructor always executes — that’s 
how the object itself is created.

@Component
public class SimpleBean {
    public SimpleBean() {
        System.out.println("[SimpleBean] Constructor called");
    }
}


When Spring starts up, you’ll definitely see this line printed:

[SimpleBean] Constructor called


No @PostConstruct is needed for that — constructors are plain Java behavior.

Where @PostConstruct fits in

@PostConstruct is a Spring-managed lifecycle callback, not a replacement for a constructor.
It runs after:

Spring calls the bean’s constructor (so the object exists),

and after dependency injection (@Autowired, @Value, etc.) is complete.

@Component
public class CricketCoach {
    @Value("${team.name}")
    private String teamName;

    public CricketCoach() {
        System.out.println("[CricketCoach] Constructor called");
    }

    @PostConstruct
    public void init() {
        System.out.println("[CricketCoach] @PostConstruct called, team = " + teamName);
    }
}


So:

Constructor runs → object created (but teamName might not be injected yet)

Dependencies injected → now fields like teamName are set

Then @PostConstruct runs → at this stage, all dependencies are ready

What happens if there is no @PostConstruct

Let’s modify your scenario:

@Component
public class SmsService implements MessageService {
    public SmsService() {
        System.out.println("[SmsService] constructor called");
    }

    // no @PostConstruct
}


When Spring starts:

It calls SmsService() constructor → prints constructor log

It injects dependencies (if any)

Then it looks for a @PostConstruct method — but finds none

Bean initialization is considered complete

So yes, it still works perfectly fine — only difference is that no extra lifecycle 
callback runs after DI.


Why @PostConstruct exists

It’s just for situations where you want to perform post-initialization work, i.e., 
tasks that need dependencies available:

Initialize or validate fields
Open connections
Log ready-state
Compute derived values, etc.
Example:

@PostConstruct
public void init() {
    System.out.println("Now that dependencies are injected, initialize things!");
}


Without it, you could still do this work in the constructor, but:

In constructor, injected fields may still be null.
In @PostConstruct, everything is already wired and ready.

Integrating this into your earlier example

Let’s align this with your CricketCoach / FootballCoach / TrainingService setup:

| Bean            | Has Constructor | Has @PostConstruct | Behavior                                                                 |
| --------------- | --------------- | ------------------ | ------------------------------------------------------------------------ |
| CricketCoach    | ✅ Yes           | ❌ No               | Constructor runs during creation; no post-init work                      |
| FootballCoach   | ✅ Yes           | ❌ No               | Constructor runs only when bean requested (prototype); no post-init work |
| ScoreRepository | ✅ Yes           | ❌ No               | Constructor runs during startup; no post-init work                       |
| TrainingService | ✅ Yes           | ❌ No               | Constructor runs after dependencies ready; no post-init work             |

Everything works fine — you just won’t see any “PostConstruct called” messages, because there aren’t any.


Difference summarized clearly
| Stage                    | Happens for every bean?     | Trigger              | Purpose                              |
| ------------------------ | --------------------------- | -------------------- | ------------------------------------ |
| **Constructor**          | ✅ Always                    | Java object creation | Allocate memory and create instance  |
| **Dependency Injection** | ✅ Always                    | Spring               | Inject other beans / values          |
| **@PostConstruct**       | ❌ Optional                  | Spring (after DI)    | Custom init code when bean is ready  |
| **@PreDestroy**          | ❌ Optional (Singleton only) | Spring (on shutdown) | Custom cleanup before context closes |


Quick example showing timing difference

@Component
public class ExampleBean {

    @Value("${app.name:DefaultApp}")
    private String appName;

    public ExampleBean() {
        System.out.println("Constructor: appName = " + appName);
    }

    @PostConstruct
    public void init() {
        System.out.println("@PostConstruct: appName = " + appName);
    }
}


Console output:

Constructor: appName = null
@PostConstruct: appName = DefaultApp


The field wasn’t injected yet during the constructor call, but is available in 
@PostConstruct.

| Concept                   | What It Does                         | When It Runs     | Needed?          |
| ------------------------- | ------------------------------------ | ---------------- | ---------------- |
| **Constructor**           | Creates object                       | Always           | Mandatory (Java) |
| **@PostConstruct**        | Runs after dependencies are injected | After DI         | Optional         |
| **@PreDestroy**           | Cleanup before shutdown              | On context close | Optional         |
| **@Primary / @Qualifier** | Affects *which* bean is injected     | At DI time       | Optional         |


Would you like me to show this difference (constructor vs @PostConstruct) in your existing 
CricketCoach / FootballCoach project logs side-by-side — i.e., what prints when only 
constructor is used vs when @PostConstruct is active?
It’ll make the timing sequence visually clear in console output.




let’s demonstrate the exact difference between having only a constructor 
and having a @PostConstruct method in your current Spring Core setup, with clear 
console logs.

Project setup reminder

You already have:
CricketCoach → Singleton (default scope)
FootballCoach → Prototype
TrainingService → uses @Qualifier("cricketCoach")
AppConfig → with component scan and property source
MainApp → manually closes the context (so @PreDestroy triggers for singletons)
Now let’s modify just your CricketCoach and FootballCoach slightly to observe 
the differences.



Version 1 – Only Constructor (No @PostConstruct)

CricketCoach.java
@Component
public class CricketCoach implements Coach {

    @Value("${team.name}")
    private String teamName;

    public CricketCoach() {
        System.out.println("[CricketCoach] Constructor called, teamName = " + teamName);
    }

    @Override
    public String getDailyWorkout() {
        return "Cricket drills for team: " + teamName;
    }
}

FootballCoach.java
@Component
@Scope("prototype")
public class FootballCoach implements Coach {

    private static int counter = 0;
    private final int instanceId;

    public FootballCoach() {
        instanceId = ++counter;
        System.out.println("[FootballCoach] Constructor called, instanceId = " + instanceId);
    }

    @Override
    public String getDailyWorkout() {
        return "Football drills for instance #" + instanceId;
    }
}


Console output (only constructor case)
Bootstraping Spring Core...
[CricketCoach] Constructor called, teamName = null
[TrainingService] constructor called
[FootballCoach] not printed (prototype, not requested)
[TrainingService] prevScore = 1281289714 | Plan: Cricket drills for team: 
null Method Parameter, team name: Mumbai Indians


Observation:

The constructor runs before dependency injection, so teamName (from @Value) is still null.
There’s no @PostConstruct, so Spring moves on after injection silently.
FootballCoach not created yet, since no one requested it (prototype).


Version 2 – Constructor + @PostConstruct
Now, let’s add @PostConstruct to observe the lifecycle clearly.

CricketCoach.java
@Component
public class CricketCoach implements Coach {

    @Value("${team.name}")
    private String teamName;

    public CricketCoach() {
        System.out.println("[CricketCoach] Constructor called, teamName = " + teamName);
    }

    @PostConstruct
    public void init() {
        System.out.println("[CricketCoach] @PostConstruct called, teamName = " + teamName);
    }

    @PreDestroy
    public void destroy() {
        System.out.println("[CricketCoach] @PreDestroy called");
    }

    @Override
    public String getDailyWorkout() {
        return "Cricket drills for team: " + teamName;
    }
}

Console output (constructor + @PostConstruct)
Bootstraping Spring Core...
[CricketCoach] Constructor called, teamName = null
[CricketCoach] @PostConstruct called, teamName = Royal Challengers
[TrainingService] constructor called
[Training Service] prevScore = 1281289714 | Plan: Cricket drills for team: Royal Challengers 
Method Parameter, team name: Mumbai Indians
[CricketCoach] @PreDestroy called


Now you can clearly see:

| Phase                | Log                            | Explanation                                             |
| -------------------- | ------------------------------ | ------------------------------------------------------- |
| Constructor          | `teamName = null`              | Bean object created, but property not yet injected      |
| Dependency Injection | *(happens silently)*           | Spring injects `teamName` from `application.properties` |
| @PostConstruct       | `teamName = Royal Challengers` | Runs after DI — dependencies are ready                  |
| @PreDestroy          | Called on ctx.close()          | Runs when context shuts down                            |


Version 3 – Prototype bean comparison (FootballCoach)

If you now add:

ctx.getBean(FootballCoach.class);
ctx.getBean(FootballCoach.class);


at the end of your MainApp,
you’ll see:

[FootballCoach] Constructor called, instanceId = 1
[FootballCoach] Constructor called, instanceId = 2


If you add @PostConstruct inside FootballCoach:

@PostConstruct
public void init() {
    System.out.println("[FootballCoach] @PostConstruct called, instanceId = " + instanceId);
}


Output becomes:

[FootballCoach] Constructor called, instanceId = 1
[FootballCoach] @PostConstruct called, instanceId = 1
[FootballCoach] Constructor called, instanceId = 2
[FootballCoach] @PostConstruct called, instanceId = 2


❗ But notice — @PreDestroy will not run for prototype beans automatically, 
even when you call ctx.close().

🔍 Consolidated Understanding
| Bean Type         | Scope     | Constructor                     | @PostConstruct                 | @PreDestroy        |
| ----------------- | --------- | ------------------------------- | ------------------------------ | ------------------ |
| `CricketCoach`    | Singleton | Called at startup               | Called after DI                | Called on shutdown |
| `FootballCoach`   | Prototype | Called when requested           | Called after DI (per instance) | ❌ Not auto-called  |
| `TrainingService` | Singleton | Called after dependencies ready | No PostConstruct               | Called on shutdown |
| `ScoreRepository` | Singleton | Called at startup               | None                           | Called on shutdown |


Timeline visualization (final)

Spring Context Bootstraps
   ↓
[CricketCoach] Constructor (teamName = null)
   ↓
Spring injects @Value fields (teamName = Royal Challengers)
   ↓
[CricketCoach] @PostConstruct called
   ↓
[TrainingService] constructor runs (injected CricketCoach + ScoreRepository)
   ↓
App logic executes
   ↓
ctx.close()
   ↓
[CricketCoach] @PreDestroy called


| Concept              | Constructor Only       | Constructor + @PostConstruct      |
| -------------------- | ---------------------- | --------------------------------- |
| **When runs**        | During object creation | After constructor + DI            |
| **Fields injected?** | ❌ Not yet              | ✅ Already injected                |
| **Purpose**          | Allocate object        | Run post-setup logic              |
| **Effect on app**    | Works fine             | Adds lifecycle safety and clarity |



