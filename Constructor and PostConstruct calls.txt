Fantastic ‚Äî you‚Äôve built a really clean and realistic Spring Core example

Let‚Äôs understand step by step, with reasoning behind constructor calls, @Primary, 
@Qualifier, @PostConstruct, and @PreDestroy

We have:

| Component         | Type                                                     | Scope               | Special                                            |
| ----------------- | -------------------------------------------------------- | ------------------- | -------------------------------------------------- |
| `CricketCoach`    | `@Component`                                             | Singleton (default) | Has commented-out `@PostConstruct` / `@PreDestroy` |
| `FootballCoach`   | `@Component`                                             | Prototype           | Marked `@Primary`                                  |
| `ScoreRepository` | `@Repository`                                            | Singleton           | Used by `TrainingService`                          |
| `TrainingService` | `@Service`                                               | Singleton           | Injects `Coach` + `ScoreRepository`                |
| `MainApp`         | Manually bootstraps `AnnotationConfigApplicationContext` | ‚Äî                   | Calls `ctx.close()`                                |


So:
We have 2 Coach beans: cricketCoach(singleton) and footballCoach(prototype).
We inject @Qualifier("cricketCoach") inside TrainingService.

What happens when the app starts

Step 1: Context Creation
AnnotationConfigApplicationContext ctx = new 
AnnotationConfigApplicationContext(AppConfig.class);

Spring:Loads AppConfig
Runs component scanning on com.example.springcore.annotations
Finds all @Component, @Service, @Repository beans.

Beans discovered:
cricketCoach, footballCoach, scoreRepository, trainingService

Step 2: Bean Instantiation Sequence
Spring needs to create trainingService, but before that it must resolve its dependencies.


public TrainingService(@Qualifier("cricketCoach") Coach coach, ScoreRepository repo) {
Spring must provide:
a Coach bean named "cricketCoach"
a ScoreRepository bean
So internally:
It sees @Qualifier("cricketCoach"), so it specifically chooses the CricketCoach 
bean (even though FootballCoach is @Primary ‚Äî Qualifier always wins).

Creates CricketCoach first.
Creates ScoreRepository.
Injects both into TrainingService.
Creates the TrainingService bean itself.

Step 3: Constructor invocation order
So you‚Äôll see (assuming you uncomment the PostConstruct later):

[FootballCoach] constructor: instance id#1 - not yet
[CricketCoach] constructor called
[TrainingService] constructor called

Wait ‚Äî FootballCoach constructor won‚Äôt appear unless it‚Äôs actually requested.
Because:
It‚Äôs a prototype bean, and
It‚Äôs not injected anywhere,
so Spring knows about it but doesn‚Äôt instantiate it until someone explicitly calls 
ctx.getBean(FootballCoach.class).

IMPORTANT POINT: Singleton beans are created eagerly during context startup.
IMPORTANT POINT: Prototype beans are created lazily (only when requested).


Step 4: @PostConstruct invocation
Now Spring calls any methods annotated with @PostConstruct.
But your CricketCoach has:

//@PostConstruct
public void init() { ... }
Because @PostConstruct is commented out, it will never run.
That‚Äôs why you didn‚Äôt see it in your logs.

If you uncomment @PostConstruct:

@PostConstruct
public void init() {
    System.out.println("[CricketCoach] @PostConstruct: Ready for training, Team:" + teamName);
}

then after the constructor and dependency injection, Spring will call it automatically.

Step 5: @PreDestroy invocation
Now, when you call:

ctx.close();

Spring gracefully shuts down the context.
It will invoke all @PreDestroy methods for singleton beans only.
Prototype beans do not receive destroy callbacks automatically (you‚Äôd have to destroy 
them manually).

So if you uncomment this:

@PreDestroy
public void destroy() {
    System.out.println("[CricketCoach] @PreDestroy: Wrapping up resource");
}

You‚Äôll see this message when you close the context.


| Bean            | Scope     | When Constructor Runs      | @PostConstruct              | @PreDestroy        | Injected?            |
| --------------- | --------- | -------------------------- | --------------------------- | ------------------ | -------------------- |
| CricketCoach    | Singleton | At startup                 | Yes (if annotation present) | Yes (on ctx.close) | Yes (via @Qualifier) |
| FootballCoach   | Prototype | Only if `getBean()` called | Yes (if annotation present) | ‚ùå Not automatic    | Not injected         |
| ScoreRepository | Singleton | At startup                 | (no method)                 | (no method)        | Yes                  |
| TrainingService | Singleton | After dependencies created | (no method)                 | (no method)        | n/a                  |


Why you saw only one constructor called
Because:
You never requested FootballCoach from context,
And it‚Äôs prototype scoped (so it‚Äôs lazy).
Hence, Spring never instantiated it.

If you do this in your MainApp:

ctx.getBean(FootballCoach.class);
you‚Äôll suddenly see:

[FootballCoach] constructor: instance id#1
And if you call it twice:

ctx.getBean(FootballCoach.class);
ctx.getBean(FootballCoach.class);
you‚Äôll see:

[FootballCoach] constructor: instance id#1
[FootballCoach] constructor: instance id#2

because prototype beans always create a new instance.

@Primary vs @Qualifier clarity


| Situation                                  | Which Bean Injected                                 |
| ------------------------------------------ | --------------------------------------------------- |
| `@Primary` on FootballCoach, no @Qualifier | FootballCoach injected                              |
| `@Qualifier("cricketCoach")` used          | CricketCoach injected (Qualifier overrides Primary) |
| No @Primary and no @Qualifier              | ‚ùå Ambiguity error                                   |
| Only one Coach bean present                | That one injected automatically                     |


So, your case:

public TrainingService(@Qualifier("cricketCoach") Coach coach, ...)
explicitly chooses CricketCoach, ignoring the @Primary on FootballCoach.

Visual timeline for your current setup

Spring Context Bootstraps ‚Üí
  ‚Üì
Finds beans: CricketCoach, FootballCoach, ScoreRepository, TrainingService
  ‚Üì
CricketCoach constructor runs
  ‚Üì
CricketCoach @PostConstruct (if present)
  ‚Üì
ScoreRepository created
  ‚Üì
TrainingService constructor runs (gets injected CricketCoach + ScoreRepository)
  ‚Üì
TrainingService ready
  ‚Üì
App logic runs (service.trainingPlan(...))
  ‚Üì
ctx.close()
  ‚Üì
CricketCoach @PreDestroy called

Small Experiment You Can Try
Try these quick toggles and watch logs change:

| Change                                                            | What Happens                                  |
| ----------------------------------------------------------------- | --------------------------------------------- |
| Uncomment `@PostConstruct` & `@PreDestroy` in CricketCoach        | See lifecycle messages                        |
| Remove `@Qualifier` from TrainingService                          | App fails (ambiguous Coach)                   |
| Add `@Primary` on CricketCoach instead                            | App works without @Qualifier                  |
| Keep `@Qualifier("cricketCoach")` but mark FootballCoach @Primary | Works fine, because Qualifier wins            |
| Call `ctx.getBean(FootballCoach.class)` twice                     | See new instance created twice                |
| Add `@Scope("prototype")` to CricketCoach                         | Now its `@PreDestroy` won‚Äôt run automatically |



The key principle to remember

Spring creates all singleton beans at startup.
Prototype beans are created only when requested.
@PostConstruct runs after dependency injection.
@PreDestroy runs only for singletons on context close.
@Qualifier always overrides @Primary.




what if one bean has no @PostContruct, it has simple constructor in a class, 
will it work and how that falls in above understanding?


Every Spring bean must have a constructor

When you mark a class as a Spring-managed bean (@Component, @Service, etc.), Spring must 
create an instance of that class.

So, even if you don‚Äôt write @PostConstruct, the bean‚Äôs constructor always executes ‚Äî that‚Äôs 
how the object itself is created.

@Component
public class SimpleBean {
    public SimpleBean() {
        System.out.println("[SimpleBean] Constructor called");
    }
}


When Spring starts up, you‚Äôll definitely see this line printed:

[SimpleBean] Constructor called


No @PostConstruct is needed for that ‚Äî constructors are plain Java behavior.

Where @PostConstruct fits in

@PostConstruct is a Spring-managed lifecycle callback, not a replacement for a constructor.
It runs after:

Spring calls the bean‚Äôs constructor (so the object exists),

and after dependency injection (@Autowired, @Value, etc.) is complete.

@Component
public class CricketCoach {
    @Value("${team.name}")
    private String teamName;

    public CricketCoach() {
        System.out.println("[CricketCoach] Constructor called");
    }

    @PostConstruct
    public void init() {
        System.out.println("[CricketCoach] @PostConstruct called, team = " + teamName);
    }
}


So:

Constructor runs ‚Üí object created (but teamName might not be injected yet)

Dependencies injected ‚Üí now fields like teamName are set

Then @PostConstruct runs ‚Üí at this stage, all dependencies are ready

What happens if there is no @PostConstruct

Let‚Äôs modify your scenario:

@Component
public class SmsService implements MessageService {
    public SmsService() {
        System.out.println("[SmsService] constructor called");
    }

    // no @PostConstruct
}


When Spring starts:

It calls SmsService() constructor ‚Üí prints constructor log

It injects dependencies (if any)

Then it looks for a @PostConstruct method ‚Äî but finds none

Bean initialization is considered complete

So yes, it still works perfectly fine ‚Äî only difference is that no extra lifecycle 
callback runs after DI.


Why @PostConstruct exists

It‚Äôs just for situations where you want to perform post-initialization work, i.e., 
tasks that need dependencies available:

Initialize or validate fields
Open connections
Log ready-state
Compute derived values, etc.
Example:

@PostConstruct
public void init() {
    System.out.println("Now that dependencies are injected, initialize things!");
}


Without it, you could still do this work in the constructor, but:

In constructor, injected fields may still be null.
In @PostConstruct, everything is already wired and ready.

Integrating this into your earlier example

Let‚Äôs align this with your CricketCoach / FootballCoach / TrainingService setup:

| Bean            | Has Constructor | Has @PostConstruct | Behavior                                                                 |
| --------------- | --------------- | ------------------ | ------------------------------------------------------------------------ |
| CricketCoach    | ‚úÖ Yes           | ‚ùå No               | Constructor runs during creation; no post-init work                      |
| FootballCoach   | ‚úÖ Yes           | ‚ùå No               | Constructor runs only when bean requested (prototype); no post-init work |
| ScoreRepository | ‚úÖ Yes           | ‚ùå No               | Constructor runs during startup; no post-init work                       |
| TrainingService | ‚úÖ Yes           | ‚ùå No               | Constructor runs after dependencies ready; no post-init work             |

Everything works fine ‚Äî you just won‚Äôt see any ‚ÄúPostConstruct called‚Äù messages, because there aren‚Äôt any.


Difference summarized clearly
| Stage                    | Happens for every bean?     | Trigger              | Purpose                              |
| ------------------------ | --------------------------- | -------------------- | ------------------------------------ |
| **Constructor**          | ‚úÖ Always                    | Java object creation | Allocate memory and create instance  |
| **Dependency Injection** | ‚úÖ Always                    | Spring               | Inject other beans / values          |
| **@PostConstruct**       | ‚ùå Optional                  | Spring (after DI)    | Custom init code when bean is ready  |
| **@PreDestroy**          | ‚ùå Optional (Singleton only) | Spring (on shutdown) | Custom cleanup before context closes |


Quick example showing timing difference

@Component
public class ExampleBean {

    @Value("${app.name:DefaultApp}")
    private String appName;

    public ExampleBean() {
        System.out.println("Constructor: appName = " + appName);
    }

    @PostConstruct
    public void init() {
        System.out.println("@PostConstruct: appName = " + appName);
    }
}


Console output:

Constructor: appName = null
@PostConstruct: appName = DefaultApp


The field wasn‚Äôt injected yet during the constructor call, but is available in 
@PostConstruct.

| Concept                   | What It Does                         | When It Runs     | Needed?          |
| ------------------------- | ------------------------------------ | ---------------- | ---------------- |
| **Constructor**           | Creates object                       | Always           | Mandatory (Java) |
| **@PostConstruct**        | Runs after dependencies are injected | After DI         | Optional         |
| **@PreDestroy**           | Cleanup before shutdown              | On context close | Optional         |
| **@Primary / @Qualifier** | Affects *which* bean is injected     | At DI time       | Optional         |


Would you like me to show this difference (constructor vs @PostConstruct) in your existing 
CricketCoach / FootballCoach project logs side-by-side ‚Äî i.e., what prints when only 
constructor is used vs when @PostConstruct is active?
It‚Äôll make the timing sequence visually clear in console output.




let‚Äôs demonstrate the exact difference between having only a constructor 
and having a @PostConstruct method in your current Spring Core setup, with clear 
console logs.

Project setup reminder

You already have:
CricketCoach ‚Üí Singleton (default scope)
FootballCoach ‚Üí Prototype
TrainingService ‚Üí uses @Qualifier("cricketCoach")
AppConfig ‚Üí with component scan and property source
MainApp ‚Üí manually closes the context (so @PreDestroy triggers for singletons)
Now let‚Äôs modify just your CricketCoach and FootballCoach slightly to observe 
the differences.



Version 1 ‚Äì Only Constructor (No @PostConstruct)

CricketCoach.java
@Component
public class CricketCoach implements Coach {

    @Value("${team.name}")
    private String teamName;

    public CricketCoach() {
        System.out.println("[CricketCoach] Constructor called, teamName = " + teamName);
    }

    @Override
    public String getDailyWorkout() {
        return "Cricket drills for team: " + teamName;
    }
}

FootballCoach.java
@Component
@Scope("prototype")
public class FootballCoach implements Coach {

    private static int counter = 0;
    private final int instanceId;

    public FootballCoach() {
        instanceId = ++counter;
        System.out.println("[FootballCoach] Constructor called, instanceId = " + instanceId);
    }

    @Override
    public String getDailyWorkout() {
        return "Football drills for instance #" + instanceId;
    }
}


Console output (only constructor case)
Bootstraping Spring Core...
[CricketCoach] Constructor called, teamName = null
[TrainingService] constructor called
[FootballCoach] not printed (prototype, not requested)
[TrainingService] prevScore = 1281289714 | Plan: Cricket drills for team: 
null Method Parameter, team name: Mumbai Indians


Observation:

The constructor runs before dependency injection, so teamName (from @Value) is still null.
There‚Äôs no @PostConstruct, so Spring moves on after injection silently.
FootballCoach not created yet, since no one requested it (prototype).


Version 2 ‚Äì Constructor + @PostConstruct
Now, let‚Äôs add @PostConstruct to observe the lifecycle clearly.

CricketCoach.java
@Component
public class CricketCoach implements Coach {

    @Value("${team.name}")
    private String teamName;

    public CricketCoach() {
        System.out.println("[CricketCoach] Constructor called, teamName = " + teamName);
    }

    @PostConstruct
    public void init() {
        System.out.println("[CricketCoach] @PostConstruct called, teamName = " + teamName);
    }

    @PreDestroy
    public void destroy() {
        System.out.println("[CricketCoach] @PreDestroy called");
    }

    @Override
    public String getDailyWorkout() {
        return "Cricket drills for team: " + teamName;
    }
}

Console output (constructor + @PostConstruct)
Bootstraping Spring Core...
[CricketCoach] Constructor called, teamName = null
[CricketCoach] @PostConstruct called, teamName = Royal Challengers
[TrainingService] constructor called
[Training Service] prevScore = 1281289714 | Plan: Cricket drills for team: Royal Challengers 
Method Parameter, team name: Mumbai Indians
[CricketCoach] @PreDestroy called


Now you can clearly see:

| Phase                | Log                            | Explanation                                             |
| -------------------- | ------------------------------ | ------------------------------------------------------- |
| Constructor          | `teamName = null`              | Bean object created, but property not yet injected      |
| Dependency Injection | *(happens silently)*           | Spring injects `teamName` from `application.properties` |
| @PostConstruct       | `teamName = Royal Challengers` | Runs after DI ‚Äî dependencies are ready                  |
| @PreDestroy          | Called on ctx.close()          | Runs when context shuts down                            |


Version 3 ‚Äì Prototype bean comparison (FootballCoach)

If you now add:

ctx.getBean(FootballCoach.class);
ctx.getBean(FootballCoach.class);


at the end of your MainApp,
you‚Äôll see:

[FootballCoach] Constructor called, instanceId = 1
[FootballCoach] Constructor called, instanceId = 2


If you add @PostConstruct inside FootballCoach:

@PostConstruct
public void init() {
    System.out.println("[FootballCoach] @PostConstruct called, instanceId = " + instanceId);
}


Output becomes:

[FootballCoach] Constructor called, instanceId = 1
[FootballCoach] @PostConstruct called, instanceId = 1
[FootballCoach] Constructor called, instanceId = 2
[FootballCoach] @PostConstruct called, instanceId = 2


‚ùó But notice ‚Äî @PreDestroy will not run for prototype beans automatically, 
even when you call ctx.close().

üîç Consolidated Understanding
| Bean Type         | Scope     | Constructor                     | @PostConstruct                 | @PreDestroy        |
| ----------------- | --------- | ------------------------------- | ------------------------------ | ------------------ |
| `CricketCoach`    | Singleton | Called at startup               | Called after DI                | Called on shutdown |
| `FootballCoach`   | Prototype | Called when requested           | Called after DI (per instance) | ‚ùå Not auto-called  |
| `TrainingService` | Singleton | Called after dependencies ready | No PostConstruct               | Called on shutdown |
| `ScoreRepository` | Singleton | Called at startup               | None                           | Called on shutdown |


Timeline visualization (final)

Spring Context Bootstraps
   ‚Üì
[CricketCoach] Constructor (teamName = null)
   ‚Üì
Spring injects @Value fields (teamName = Royal Challengers)
   ‚Üì
[CricketCoach] @PostConstruct called
   ‚Üì
[TrainingService] constructor runs (injected CricketCoach + ScoreRepository)
   ‚Üì
App logic executes
   ‚Üì
ctx.close()
   ‚Üì
[CricketCoach] @PreDestroy called


| Concept              | Constructor Only       | Constructor + @PostConstruct      |
| -------------------- | ---------------------- | --------------------------------- |
| **When runs**        | During object creation | After constructor + DI            |
| **Fields injected?** | ‚ùå Not yet              | ‚úÖ Already injected                |
| **Purpose**          | Allocate object        | Run post-setup logic              |
| **Effect on app**    | Works fine             | Adds lifecycle safety and clarity |



